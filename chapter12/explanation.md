* How sleeping processes are represented.  
Sleeping processes are represented by their pcb being placed in the sleep_queue in the scheduler, which only consists of sleeping processes.
* How wake-ups are triggered.  
Wake-ups are triggered by the scheduler going through the entire sleep_queue at the very start of sched_block (which finds a new process to run) and checking the deadline of each process and waking any processes where the current time, as given by mtime_get and time_base, is greater than the deadline of the process. The process is woken up by being removed from the sleep_queue and being placed back on the run queue with sched_resume before the rest of sched_block executes.
* Any scheduler design decisions you made.   
We decided to implement the sleep_queue with the same circular queue structure that was used to implement the run queue, as we could leverage the existing functions to enqueue into the queue, which simplified the logic. We also decided to check the entire queue at the start of sched_block because we did not anticipate that there would be a very high number of processes which would need to be sleeping at any particular moment, so we did not believe this implementation would drastically slow down the scheduler.
* How you used AI, if at all.  
We used AI to understand the necessity of calling sched_block after sched_sleep, as the CPU would need a context switch to be able to continue executing while the current process is sleeping. We also used AI to identify and fix a bug in the scheduler when waking up a process, as it is not correct to call sched_resume on a process we want to wake up before we proceed to the next element in the sleep queue, as calling sched_resume will change the address that process->next points to, which means the next element when we check the sleep queue is not a sleeping process.